https://thecode.media/yagni/

```
    SOLID — это целый набор правил, а название образовалось по первым буквам каждого из них. 
    Такой подход часто используется в крупных проектах и в командной работе над кодом.

    1. Single responsibility principle — принцип единой ответственности. 
    В общем виде это правило можно сформулировать так: одна функция должна выполнять только одну задачу и не быть 
    универсальной для всех ситуаций. 
    Это иногда противоречит принципу DRY, поэтому тут каждая команда решает сама, какое правило в каких случаях нужно 
    использовать.

    2. Open-closed principle — принцип открытости и закрытости. 
    Он означает, что все модули, библиотеки и расширения, которыми могут пользоваться другие программисты, должны быть 
    открыты для расширения и закрыты для изменений. 
    
    Например, если вы делаете внешний модуль для работы со временем, он должен понимать разные форматы даты и в него 
    можно передавать время в разных форматах. При этом изменить поведение модуля не получится: независимо от того, что 
    в него передаётся, он всегда делает одно и то же по стандартным сценариям.

    3. Liskov substitution principle — принцип подстановки Лисков. 
    Барбара Лисков придумала основу для этого принципа, когда работала над принципами работы ООП. 
    Если сильно упростить, то получится так: представим, что у нас есть базовые объекты, а у них — свои вложенные 
    другие объекты и свойства. По принципу подстановки Лисков функция, которая использует базовые объекты, может 
    использовать и её вложенные объекты без дополнительных объявлений или сложных конструкций. 
    
    4. Interface segregation principle — принцип разделения интерфейса. 
    Интерфейс в программировании — это то, что умеет делать функция, класс или объект. 
    
    Например, у объекта «сетевое подключение» могут быть интерфейсы «подключиться», «отключиться», «проверить связь» и 
    «передать данные». 
    
    Принцип разделения означает, что если мы поменяем внутри что-то в одном интерфейсе, это не должно сломать работу 
    остальных интерфейсов.
    
    5. Dependency inversion principle — принцип инверсии зависимостей. 
    
    Смысл в том, чтобы зависимости, например от внешней базы данных, не встраивались жёстко в тело модуля, а были одним 
    из аргументов, от которых зависит выполнение этого модуля. Если нам нужно будет поменять базу данных, с которой 
    работает модуль, достаточно будет сделать это при вызове, а не править исходную функцию.
```