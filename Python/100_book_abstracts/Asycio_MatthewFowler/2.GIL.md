### Глобальная блокировка интерпретатора (global interpreter lock – GIL) – 
```    
    Говоря кратко, GIL не дает Python-процессу исполнять более одной команды байт-кода в каждый момент времени. 
    
    Это означает, что, даже если имеется несколько потоков на многоядерной машине, интерпретатор сможет 
    в каждый момент исполнять только один поток, содержащий написанный на Python код. 
```

Многопроцессные приложения могут конкурентно выполнять несколько команд байт-кода, потому что 
у каждого Python-процесса своя собственная GIL

### Для чего же нужна GIL?
```
    Ответ кроется в том, как CPython управляет памятью. 
    В CPython память управляется в основном с помощью подсчета ссылок.
    То есть для каждого объекта Python, например целого числа, словаря или списка, подсчитывается, сколько объектов 
    в данный момент используют его. Когда объект перестает быть нужным кому-то, счетчик ссылок на него уменьшается, 
    а когда кто-то новый обращается к нему, счетчик ссылок увеличивается. Если счетчик ссылок обратился в нуль, значит, 
    на объект никто не ссылается, поэтому его можно удалить из памяти.
    
    Конфликт потоков возникает из-за того, что интерпретатор CPython НЕ ЯВЛЯЕТСЯ ПОТОКОБЕЗОПАСНЫМ. 
    Это означает, что если два или более потоков модифицируют разделяемую переменную, то ее конечное состояние может 
    оказаться неожиданным, поскольку зависит от порядка доступа к  переменной со стороны потоков. 
    
    Эта ситуация называется СОСТОЯНИЕМ ГОНКИ. 
    
    Состояния гонки могут возникать, когда два потока одновременно обращаются к одному объекту Python
```

### Освобождается ли когда-нибудь GIL?
```
    1. Глобальная блокировка интерпретатора освобождается на время выполнения операций ввода-вывода.
    
        - Это позволяет использовать потоки для конкурентного выполнения ввода-вывода, но не для выполнения 
          счетного кода, написанного на Python (есть исключения, когда GIL все же освобождается на время 
          выполнения счетных задач). 

```

### почему же GIL освобождается при вводе-выводе, но не освобождается для счетных задач?
```
    Все дело в системных вызовах, которые выполняются за кулисами. 
    
    В  случае ввода-вывода низкоуровневые системные вызовы работают за пределами среды выполнения Python.
    Это позволяет освободить GIL, потому что код операционной системы не взаимодействует напрямую с объектами Python. 
    GIL захватывается снова, только когда полученные данные переносятся в объект Python. Стало быть, на уровне ОС 
    операции ввода-вывода выполняются конкурентно. 
    
    Эта модель обеспечивает конкурентность, но не параллелизм. В других языках, например Java или C++, на 
    многоядерных машинах можно организовать истинный параллелизм, потому что никакой GIL нет и код может
    выполняться строго одновременно. Но в Python лучшее, на что можно рассчитывать, – конкурентность 
    операций ввода-вывода, поскольку в любой момент может выполняться только один кусок написанного на Python кода.
```

В Python многопоточность может быть реализована только конкурентно.

### Аsyncio и GIL
```
    В asyncio используется тот факт, что операции ввода-вывода освобождают GIL, что позволяет реализовать 
    конкурентность даже в одном потоке. При работе с asyncio мы создаем объекты сопрограмм. 
    
    Сопрограмму можно представлять себе как облегченный поток. Точно так же, как может быть несколько потоков, 
    работающих одновременно и исполняющих разные операции ввода-вывода, так может существовать много сопрограмм, 
    работающих бок о бок. Ожидая завершения сопрограмм, занимающихся вводом-выводом, мы можем выполнять другой 
    Python-код, получая таким образом конкурентность. 
    
    Важно отметить, что asyncio не обходит GIL, мы по-прежнему ограничены ей. 
    Если имеется счетная задача, то для ее конкурентного выполнения все равно нужно заводить отдельный процесс 
    (и в asyncio есть для этого средства), иначе производительность снизится. 
```