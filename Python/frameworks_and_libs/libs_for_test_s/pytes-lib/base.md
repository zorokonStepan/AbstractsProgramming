```
    pytest -v
        -v выводит имя каждого теста в новой строке
```

### Пропуск тестов
```
    pytest.skip()
    
    @pytest.mark.skip
```

### Запуск определенных тестов
```
    -k фильтрация тестов по имени
    
    pytest -v examples/test_skip.py -k test_fail
    
    --------
    
    -m маркировка тестов
    
    @pytest.mark.dicttest
    def test_something():
        pass
        
        
    pytest -v test_mark.py -m dicttest
    
    Или запустить все тесты которые не имеют метки
    
    pytest -v test_mark.py -m 'not dicttest'
    
    Pytest принимает сложные выражения с or, and, not.    
```

### Параллельный запуск тестов
```
    pip install pytest-xdist
    
    этот плагин расширяет команднуб строку --numprocesses или -n
    
    pytest -n 4 запустит тестовый набор в 4 параллельных процессах, сохраняя баланс между загруженностью доступных ядер
    
    pytest -n auto автоматически распределит тесты по доступным ядрам
```

### Соэдание объектов, используемых в тестах, с помощью фикстур
```
    В модульном тестировании часто придется выполнять набор стандартных операций до и после запуска теста, 
    и эти инструкции задействуют определенные компоненты. 
    
    Например, может понадобиться объект, который будет выражать состояние конфигурации приложения, и он должен 
    инициализироваться перед каждым тестированием, а потом сбрасываться до начальных значений после выполнения. 
    
    Аналогично, если тест зависит от временного файла, этот файл должен создаваться перед тестом и удаляться после. 
    
    Такие компоненты называются фикстурами. 
    
    Они устанавливаются перед тестированием и пропадают после его выполнения. 
    
    1.
    В pytest фикстуры объявляются как простые функции. Функция фикстуры должна возвращать желаемый объект, чтобы в 
    тестировании, где она используется, мог использоваться этот объект. 
     
    import pytest
         
     
    @pytest.fixture    
    def database(): 
        return <some database connection> 

    def test_insert(database): 
        database.insert(123)
        
    Фикстура базы данных автоматически используется любым тестом, который имеет аргумент database в своем списке. 
    Функция test_insert() получит результат функции database() в качестве первого аргумента и будет использовать 
    этот результат по своему усмотрению. При таком использовании фикстуры не нужно повторять код инициализации базы 
    данных несколько раз. 
    
    2.
    Еще одна распространенная особенность тестирования кода - это возможность удалять лишнее после работы фикстуры. 
    Например, закрыть соединение с базой данных. 
    
    Реализация фикстуры в качестве генератора добавит функциональность по очистке проверенных объектов.
    
    import pytest 

    @pytest.fixture 
    def database(): 
        db = <some database connection> 
        yield db 
        db.close() 

    def test_insert(database): 
        database.insert(l23)
    
    3.
    Закрытие соединения с базой данных для каждого теста может вызвать неоправданные траты вычислительных мощностей, 
    так как другие тесты могут использовать уже открытое соединение. В этом случае можно передать аргумент 
    scope в декоратор фикстуры, указывая область ее видимости:     
    
    import pytest 
    
    @pytest.fixture(scope="module") 
    def database(): 
        db = <some database connection> 
        yield db 
        db.close() 
    
    def test_insert(database): 
        database.insert(l23) 
        
    Указав параметр scope = "module", вы инициализировали фикстуру единожды для всего модуля, и теперь открытое 
    соединение с базой данных будет доступно для всех тестовых функций, запрашивающих его.    
    
    4.
    Можно запустить какой-нибудь общий код до или после теста, определив фикстуры как автоматически используемые с 
    помощью ключевого слова autouse, а не указывать их в качестве аргумента для каждой тестовой функции. 
    Конкретизация функции pytest. fixture() с помощью аргумента True, ключевого слова autouse, гарантирует, что 
    фикстура вызывается каждый раз перед запуском теста в том модуле или классе, где она объявлена.
     
    import os 
    import pytest 
    
    @pytest.fixture(autouse=True) 
    def change_user_env(): 
        curuser = os.environ.get("USER") 
        os.environ["USER"] "foobar" 
        yield 
        os.environ["USER"] curuser 
    
    def test_user(): 
        assert os.getenv("USER") == "foobar" 

    Такие автоматически включаемые функции удобны. Однако убедитесь, что не злоупотребляете фикстурами: они запускаются 
    перед каждым тестом, который попадает в их область видимости, и поэтому могут затормозить работу группы тестов.
```

### Запуск тестовых сценариев
```
    При модульном тестировании может понадобиться запустить один и тот же 
    тест, но с разными объектами, которые вызвали ошибку, или же прогнать весь 
    набор тестов на другой системе. 

    Этого легко добиться, если применить параметрические фикстуры, запускающие несколько раз все тесты, где они 
    используются единожды для каждого указанного параметра. 
    
    пример использования параметрических фикстур для запуска одного теста дважды, но с разными параметрами: 
    один раз для mysql, а второй - для postgresql. 

    import pytest 
    import myapp 
    
    @pytest.fixture(params=["mysql", "postgresql"]) 
    def database(request): 
        d = myapp.driver(request.param) 
        d.start() 
        yield d 
        d. stop() 
    
    def test_insert(database): 
        database.insert("somedata") 

    Фикстура driver получает в качестве параметра два разных значения - имена 
    драйверов баз данных, которые поддерживаются приложением. test_insert 
    запускается дважды: один раз для базы данных MySQL, а второй - для базы 
    данных PostgreSQL. Это облегчает повторное прохождение одного и того же 
    тестирования, но с разными сценариями, без добавления новых строк кода. 
```

### Управляемые тесты с объектами-пустышками 
```
    Объекты-пустышки (или заглушки, mock objects) - это объекты, которые имитируют поведение реальных объектов 
    приложения, но в особенном, управляемом состоянии. Они наиболее полезны в создании окружений, которые досконально 
    описывают условия проведения теста. Вы можете заменить все объекты, кроме тестируемого, на объекты-пустышки и 
    изолировать его, а также создать окружение для тестирования кода.
    
    Один из случаев их использования - создание НТТР-клиента. 
    Практически невозможно (или точнее, невероятно сложно) создать НТТР-сервер, на котором можно прогнать все варианты 
    ситуаций и сценарии для каждого возможного значения. НТТР-клиенты особенно сложно тестировать на сценарии ошибок.
    
    В стандартной библиотеке есть команда mock для создания объекта-пустышки.
    Начиная с Python 3.3 mock объединен с библиотекой unittest.mock. 
    Поэтому можно использовать фрагмент кода, приведенный ниже, для обеспечения обратной совместимости между Python 3.3 
    и более ранними версиями: 
    
    try: 
        from unittest import mock 
    except ImportError: 
        import mock 

    Библиотека mock очень проста в применении. Любой атрибут, доступный для объекта mock.Mock, создается динамически во 
    время выполнения программы. Такому атрибуту может быть присвоено любое значение. 
    
    1. mock используется для создания объекта-пустышки для атрибута-пустышки. 
        >>> from unittest import mock 
        >>> m = mock.Мock() 
        >>> m.some_attribute = "hello world" 
        >>> m.some_attribute     
        "hello world" 

    2. Можно также динамически создавать метод для изменяемого объекта, где создается метод-пустышка, который всегда 
    возвращает значение 42 и принимает в качестве аргумента все что угодно. 
        >>> from unittest import mock 
        >>> m = mock.Мock() 
        >>> m.some_method.return_value = 42 
        >>> m.some_method() 
        42 
        >>> m.some_method("with", "arguments") 
        42 
    
    Всего пара строк, и объект mock. Mock теперь имеет метод some_method(),который возвращает значение 42. 
    Он принимает любой тип аргумента, пока проверка того, что это за аргумент, отсутствует. 
    Динамически создаваемые методы могут также иметь (намеренные) побочные эффекты. Чтобы не быть просто шаблонными 
    методами, которые возвращают значение, они могут быть определены для выполнения полезного кода. 
    
    3. Создание метода для объекта mock.Mock с побочным эффектом 
        >>> from unittest import mock 
        >>> m = mock.Mock() 
        >>> def print_hello(): 
                print("hello world!") 
                return 43 
        >>> m.some_method.side_effect = print_hello 
        >>> m.some_method() 
        hello world! 
        43 
        >>> m.some_method.call_count 
        1 
        
    Мы присвоили целую функцию атрибуту some_method(). Технически это позволяет реализовать более сложный сценарий в 
    тесте, благодаря тому что можно включить любой необходимый для теста код в объект- пустышку. Далее нужно 
    передать этот объект в функцию, которая его ожидает. 
    
    Атрибут call_count - это простой способ проверки количества раз, когда метод был вызван. 
    Библиотека mock использует паттерн <действие - проверка>: это значит, что после тестирования нужно убедиться, 
    что действия, замененные на пустышки, были выполнены корректно. 
    
    4. Вызов методов проверки 
        >>> from unittest import mock 
        >>> m = mock.Mock() 
        >>> m.some_method('foo', 'bar') 
        <Mock name='mock.some_method()' id='26144272'> 
        >>> m.some_method.assert_called_once_with('foo', 'bar') 
        >>> m.some_method.assert_called_once_with('foo', emock.ANY) 
        >>> m.some_method.assert_called_once_with('foo', 'baz') 

        Traceback (most recent call last): 
        File "<stdin>", line 1, in <moduLe> 
        File "/usr/liЬ/python2.7/dist-packages/mock.py", line 846, in assert_called_ 
        once_with 
        return self .assert_called_with(*args, **kwargs) 
        File "/usr/liЬ/python2.7/dist-packages/mock.py", line 835, in assert_called_ 
        with 
        raise AssertionError(msg) 
        AssertionError: Expected call: some_method('foo', 'baz') 
        Actual call: some_method('foo', 'bar')
        
    Мы создали методы с аргументами foo и bar в качестве тестов, вызвав метод. 
    Простой способ проверить вызовы к объектам-пустышкам - использовать методы assert_called(), такие 
    как assert_called_once_with(). Для этих методов необходимо передать значения, которые, как вы ожидаете, будут 
    использованы при вызове метода-пустышки. Если переданные значения отличаются от используемых, то mock вызывает 
    исключение AssertionError. Если вы не знаете, какие аргументы могут быть переданы, используйте mock.ANY в качестве 
    значения; он заменит любой аргумент, передаваемый в метод-пустышку.
     
    Библиотека mock также может быть использована для замены функции, метода или объекта из внешнего модуля. 
    
    5. заменили функцию os.unlink() собственной функцией-пустышкой. Использование mock.patch. 
        >>> from unittest import mock 
        >>> import os 
        >>> def fake_os_unlink(path): 
        raise IOError("Testing!") 
        >>> with mock.patch('os.unlink', fake_os_unlink): 
        os.unlink('foobar') 
        Traceback (most recent call last): 
        File "<stdin>", line 2, in <moduLe> 
        File "<stdin>", line 2, in fake_os_unlink 
        IOError: Testing!
         
    При использовании в качестве менеджера контекста mock.patch() заменяет целевую функцию на ту, которую мы выбираем. 
    Это нужно, чтобы код, выполняемый внутри контекста, использовал исправленный метод. С методом mock.patch() можно 
    изменить любую часть внешнего кода, заставив его вести себя так, чтобы протестировать все условия для приложения.
     
    6. Использование mock.patch() для тестирования множества поведений 
        
        import pytest 
        import requests 
        
        from unittest import mock 
        
        
        class WhereisPythonError(Exception): 
            pass 
        
        def is_python_still_a_programming_language(): 
            try: 
                r = requests.get( "http://python.org") 
            except IOError: 
                pass 
            else: 
                if r.status_code == 200: 
                    return 'Python is а programming language' in r.content 
            raise WhereisPythonError("Something bad happened") 
            
        def get_fake_get(status_code, content): 
            m = moсk.Мосk() 
            m.status_code = status_code 
            m.content = content 
        
            def fake_get(url): 
                return m 
        
            return fake_get 
        
        def raise_get(url): 
            raise IOError("UnaЫe to fetch url %s" % url) 
        
        @mock.patch('requests.get', get_fake_get(200, 'Python is а programming language for sure')) 
        def test_python_is(): 
            assert is_python_still_a_programming_language() is True 
        
        @mock.patch('requests.get', get_fake_get(200, 'Python is no morе а programming language')) 
        def test_python_is_not(): 
            assert is_python_still_a_programming_language() is False 
            
        @mock.patch('requests.get', get_fake_get(404, 'Whatever')) 
            def test_bad_status_code(): 
                with pytest.raises(WhereisPythonError): 
                    is_python_still_a_programming_language() 
        
        @mock.patch('requests.get', raise_get) 
        def test_ioerror(): 
            with pytest.raises(WhereisPythonError): 
                is_python_still_a_programming_language() 
                
    п.6. реализует тестовый случай, который ищет все экземпляры строки Python is а programming language на сайте 
    http://python.org/. Не существует варианта, при котором тест не найдет ни одной заданной строки на выбранной 
    веб-странице. Чтобы получить отрицательный результат, необходимо изменить страницу, а этого сделать нельзя. 
    
    Но с помощью mock можно пойти на хитрость и изменить поведение запроса так, чтобы он возвращал ответ-пустышку с 
    выдуманной страницей, не содержащей заданной строки. Это позволит протестировать отрицательный сценарий, в котором 
    http://python.org/ не содержит заданной строки, и убедиться, что программа обрабатывает такой случай корректно. 
    
    В этом примере используется версия декоратора mock.patch(). Поведение объекта-пустышки не меняется, и было проще 
    показать пример в контексте тестовой функции. 
    
    Использование объекта-пустышки поможет сымитировать любую проблему: 
        возвращение сервером ошибки 404, ошибку ввода-вывода или ошибку задержки сети. 
    
    Мы можем убедиться, что код возвращает правильные значения или вызывает нужное исключение в каждом случае, что 
    гарантирует ожидаемое поведение кода.
```
